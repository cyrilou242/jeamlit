{{!
    Copyright Â© 2025 Cyril de Catheu (cdecatheu@hey.com)

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
}}
<!DOCTYPE html>
<html>
<head>
    <title>Jeamlit App</title>
    <link rel="stylesheet" href="{{ MATERIAL_SYMBOLS_CDN }}">
    {{> design_system.html.mustache }}
    <style>
        body {
            font-family: var(--jt-font-family);
            margin: 0;
            background-color: var(--jt-bg-primary);
            color: var(--jt-text-primary);
            line-height: var(--jt-line-height-normal);
        }
        .app-wrapper {
            display: flex;
            margin: 0 auto;
            gap: var(--jt-spacing-lg);
        }
        .layout-container {
            background: var(--jt-bg-primary);
            padding: var(--jt-spacing-xl);
        }
        .main-layout {
            flex: 1;
            min-width: 0; /* Allow shrinking */
            /* TODO make this configurable */
            max-width: 768px;
            margin: 0 auto;
        }
        .sidebar-layout {
            display: block;
            width: 256px;
            flex-shrink: 0;
            background: var(--jt-bg-secondary);
        }
        .sidebar-layout:empty {
            display: none; /* Hidden by default */
        }
    </style>
    {{ customHeaders }}
    {{> tooltip.html.mustache }}
    {{> connection-error-modal.html.mustache }}
    {{> code.html.mustache }}
</head>
<body>
<div id="app" class="app-wrapper">
    <!-- make sure this stays empty with no spaces - it uses the :empty selector to hide if there is nothing inside -->
    <div id="sidebar-container" class="layout-container sidebar-layout" data-container="sidebar"></div>
    <div id="main-container" class="layout-container main-layout" data-container="main">
        <p>Connecting to Jeamlit server...</p>
    </div>
</div>

<!-- Connection Error Modal -->
<jt-connection-error-modal id="connection-modal" prevent-close>
    <span slot="title">Connection Error</span>
    <p>Is Jeamlit still running? If you accidentally stopped Jeamlit, just restart it in your terminal:</p>
    <jt-code content="jeamlit run YourApp.java"></jt-code>
</jt-connection-error-modal>

<!-- Compilation Error Modal -->
<jt-connection-error-modal id="compilation-modal">
    <span slot="title">Compilation error</span>
    <p>Fix the compilation errors below and save the file to continue:</p>
    <jt-code id="compilation-code" content=""></jt-code>
</jt-connection-error-modal>

<script>
    const app = document.getElementById('app');
    const mainContainer = document.getElementById('main-container');
    const sidebarContainer = document.getElementById('sidebar-container');
    const connectionModal = document.getElementById('connection-modal');
    const compilationModal = document.getElementById('compilation-modal');
    const compilationCode = document.getElementById('compilation-code');

    // Track if this is the first message to clear connecting text
    let isFirstMessage = true;

    // Connection management
    let ws = null;
    let connectionState = 'disconnected'; // 'connected', 'disconnected', 'reconnecting'

    window.jeamlit = {
        sendComponentUpdate: function(componentKey, value) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'component_update',
                    componentKey: componentKey,
                    value: value
                }));
            } else {
                console.log("Failed to send update to backend. Connection to backend is not available.");
            }
        },
        sendPathUpdate: function() {
            // Parse query parameters using URLSearchParams
            const params = new URLSearchParams(window.location.search);
            const queryObj = {};
            for (const key of params.keys()) {
                queryObj[key] = params.getAll(key);
            }

            // Send path_update message to backend to trigger app re-run
            window.jeamlit.sendMessage({
                type: 'path_update',
                path: window.location.pathname,
                queryParameters: queryObj,
            });
        },
        sendMessage: function(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                console.log("Failed to send message to backend. Connection to backend is not available.");
            }
        },
    };

    // Connection management functions
    function createWebSocketConnection() {
        try {
            ws = new WebSocket('ws://localhost:{{ port }}/ws');

            ws.onclose = () => {
                console.log('WebSocket closed');
                handleConnectionLoss();
            };

            ws.onmessage = handleWebSocketMessage;

            ws.onopen = () => {
                window.jeamlit.sendPathUpdate();
                connectionState = 'connected';
                console.log('WebSocket connected');
                connectionModal.show = false;
                compilationModal.show = false;
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

        } catch (error) {
            console.error('Failed to create WebSocket:', error);
            handleConnectionLoss();
        }
    }

    function handleConnectionLoss() {
        if (connectionState === 'connected') {
            // First time losing connection - show the connection lost modal
            // wait 1s to avoid modal flickerings when a page is reloaded
            setTimeout( () => {connectionModal.show = true;}, 1000)
        }
        connectionState = 'reconnecting';
        setTimeout(() => {
            console.log('Attempting to reconnect...');
            createWebSocketConnection();
        }, 5000);
        
        // Clear websocket references
        ws = null;
    }

    function handleWebSocketMessage(event) {
        const message = JSON.parse(event.data);
        if (message.type === 'delta') {
            applyDelta(message);
        } else if (message.type === 'compilation_error') {
            showCompilationError(message.error);
        } else {
            alert(`Unknown message type ${message.type}. Please reach out to support.`);
        }
    }

    // Layout management
    const layoutContainers = new Map([
        ['main', mainContainer],
        ['sidebar', sidebarContainer]
    ]);

    // DOM mutation batching
    let pendingMutations = [];
    let mutationTimeout = null;
    let firstMutationTime = null;
    // mutations received at less than 4ms (~1 frame at 240fps) of space are batched together to avoid flickering
    // every time a mutation is received the 4ms time is reset ...
    const MUTATION_BATCH_WINDOW = 4;
    // ... so we set a hard limit to flush the batch of 16ms ~ 1 frame at 60fps
    // FIXME this means animation will only run at max 60fps (assuming 0 latency network) so we may want to make this value configurable
    //   in any case streamlit does not ensure constant frame rate because of the delivery via ws
    const MAX_BATCH_WAIT_TIME = 16;

    function createElementFromHTML(htmlString) {
        if (!htmlString) {
            return null;
        }
        const template = document.createElement('template');
        template.innerHTML = htmlString.trim();
        return template.content.firstChild;
    }

    function handleComponentRegistrations(registrations) {
        if (!registrations || registrations.length === 0) return;

        // Ensure a hidden container is present
        let container = document.getElementById('jeamlit-registrations');
        if (!container) {
            container = document.createElement('div');
            container.id = 'jeamlit-registrations';
            container.style.display = 'none';
            document.body.appendChild(container);
        }

        registrations.forEach((registration) => {
            // Parse the registration HTML safely
            const template = document.createElement('template');
            template.innerHTML = registration;
            const fragment = template.content;

            // Execute all <script> tags inside the fragment
            fragment.querySelectorAll('script').forEach((script) => {
                const newScript = document.createElement('script');
                if (script.type) newScript.type = script.type;
                if (script.src) {
                    newScript.src = script.src;
                } else {
                    newScript.textContent = script.textContent;
                }
                document.head.appendChild(newScript);
            });

            // Inject the rest of the HTML (custom elements etc.)
            container.appendChild(fragment);
        });
    }

    function applyDelta(message) {
        const {
            index = null,                 // null means append
            html,
            container,                       // should always be set
            clearBefore = false           // Default to no clearing
        } = message;

        // Clear initial "Connecting..." message on first delta
        if (isFirstMessage) {
            mainContainer.innerHTML = '';
            isFirstMessage = false;
        }

        // Close compilation modal since we're receiving successful deltas
        compilationModal.show = false;

        // Handle component registrations immediately
        handleComponentRegistrations(message.registrations);

        // Create element immediately (outside batch)
        const newElement = createElementFromHTML(html);

        // Queue DOM mutations
        pendingMutations.push({
            type: 'delta',
            index,
            element: newElement,
            container: container,
            clearBefore
        });

        // Track first mutation time
        if (!firstMutationTime) {
            firstMutationTime = Date.now();
        }

        // Check if we've waited too long
        const elapsed = Date.now() - firstMutationTime;
        if (elapsed >= MAX_BATCH_WAIT_TIME) {
            // Force immediate processing to prevent starvation
            if (mutationTimeout) {
                clearTimeout(mutationTimeout);
                mutationTimeout = null;
            }
            processMutations();
            firstMutationTime = null;
        } else {
            // Normal batch processing
            if (mutationTimeout) {
                clearTimeout(mutationTimeout);
            }

            mutationTimeout = setTimeout(() => {
                processMutations();
                mutationTimeout = null;
                firstMutationTime = null;
            }, MUTATION_BATCH_WINDOW);
        }
    }

    function processMutations() {
        if (pendingMutations.length === 0) return;

        requestAnimationFrame(() => {
            // Group mutations by container
            const mutationsByContainer = new Map();

            pendingMutations.forEach(mutation => {
                // Get target container for this container
                if (!mutationsByContainer.has(mutation.container)) {
                    mutationsByContainer.set(mutation.container, []);
                }
                mutationsByContainer.get(mutation.container).push(mutation);
            });

            // Process mutations for each container separately
            mutationsByContainer.forEach((mutations, container) => {
                const containerEl = document.querySelector(`[data-container="${container}"]`);
                if (!containerEl) {
                    throw new Error(`Nested container not found for path: ${container}. Implementation error. Please reach out to support.`);
                }

                mutations.forEach(mutation => {
                    if (mutation.clearBefore && mutation.index !== null) {
                        while (containerEl.children.length > mutation.index) {
                            containerEl.removeChild(containerEl.lastChild);
                        }
                    }
                    // in the clearing case, it can happen that the element is null to trigger a full cleanup - so checking here but not below
                    if (mutation.element) {
                        if (mutation.index !== null && mutation.index < containerEl.children.length) {
                            containerEl.children[mutation.index].replaceWith(mutation.element);
                        } else {
                            containerEl.appendChild(mutation.element);
                        }
                    }
                });
            });

            pendingMutations = [];
        });
    }

    function showCompilationError(error) {
        // Set the error message in the jt-code component
        compilationCode.content = error;
        // Show the compilation modal
        compilationModal.show = true;
    }

    // Initialize connection
    createWebSocketConnection();
</script>
</body>
</html>