{{!
    Copyright Â© 2025 Cyril de Catheu (cdecatheu@hey.com)

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
}}
<!DOCTYPE html>
<html>
<head>
    <title>Jeamlit App</title>
    <link rel="stylesheet" href="{{ MATERIAL_SYMBOLS_CDN }}">
    {{> design_system.html.mustache }}
    <style>
        html, body {
            height: 100%;
        }
        body {
            font-family: var(--jt-font-family);
            margin: 0;
            background-color: var(--jt-bg-primary);
            color: var(--jt-text-primary);
            line-height: var(--jt-line-height-normal);
        }
        .app-wrapper {
            display: flex;
            height: 100vh;
            gap: var(--jt-spacing-lg);
        }
        .layout-container {
            background: var(--jt-bg-primary);
            padding: var(--jt-spacing-xl);
            padding-bottom: 0;
            padding-top: 0;
            overflow-y: auto;
            height: 100%;
            flex: 1;
            min-width: 0; /* Allow shrinking */
        }
        .main-layout {
            /* TODO make this configurable */
            max-width: 768px;
            margin: 0 auto;

                /* likely people will ask for this - first child margin
                :first-child {
                    margin-top: 0;
                }
                */
            }
        .fixed-element {
            min-height: 3.25rem;
            background: var(--jt-bg-primary);
            margin: 0 0;
            display: block;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .full-sidebar {
            display: block;
            width: 256px;
            flex-shrink: 0;
            background: var(--jt-bg-secondary);
            position: relative;
            transition: width var(--jt-transition-normal);
            padding: 0 var(--jt-spacing-xl);
            overflow-y: auto;
            height: 100%;
        }
        
        /* Hide entire sidebar when content is empty */
        .full-sidebar:has(.sidebar-content:empty) {
            display: none;
        }
        
        /* Fallback for browsers without :has() support */
        @supports not (selector(:has(*))) {
            .sidebar-content:empty {
                display: none;
            }
            .sidebar-content:empty + * {
                display: none;
            }
        }
        
        /* Collapsed state */
        .full-sidebar.collapsed {
            width: 24px;
            background-color: var(--jt-bg-primary);
            overflow-y: hidden;
        }
        
        /* Sidebar tooling (chevron area) */
        .sidebar-tooling {
            display: flex;
            justify-content: right;
            padding-top: var(--jt-spacing-md);
        }
        
        /* Collapse button */
        .collapse-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            border-radius: var(--jt-border-radius-lg);
            color: var(--jt-text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all var(--jt-transition-fast);
        }
        
        .collapse-btn:hover {
            background: var(--jt-bg-tertiary);
            color: var(--jt-text-primary);
        }
        
        /* Hide chevron by default when sidebar is expanded */
        .full-sidebar:not(.collapsed) .collapse-btn {
            opacity: 0;
            transition: opacity var(--jt-transition-fast);
        }
        
        /* Show chevron on hover when sidebar is expanded */
        .full-sidebar:not(.collapsed):hover .collapse-btn {
            opacity: 1;
        }
        
        /* Always show chevron when collapsed */
        .full-sidebar.collapsed .collapse-btn {
            opacity: 1;
        }
        
        /* Rotate chevron when collapsed */
        .full-sidebar.collapsed .collapse-btn .material-symbols-rounded {
            transform: rotate(180deg);
        }
        
        /* Hide content when collapsed, but keep tooling visible */
        .full-sidebar.collapsed .sidebar-content {
            opacity: 0;
            pointer-events: none;
        }
        
        /* Resize handle for dragging sidebar width */
        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: -3px;
            bottom: 0;
            width: 4px;
            cursor: col-resize;
            background: transparent;
            z-index: 20;
            transition: background-color var(--jt-transition-fast);
        }
        
        .sidebar-resize-handle:hover {
            background: var(--jt-border-color);
        }
        
        /* Hide handle when sidebar is collapsed */
        .full-sidebar.collapsed .sidebar-resize-handle {
            display: none;
        }
        
        /* Prevent text selection during resize */
        body.resizing {
            user-select: none;
            cursor: col-resize;
        }
    </style>
    {{ customHeaders }}
    {{> tooltip.html.mustache }}
    {{> connection-error-modal.html.mustache }}
    {{> code.html.mustache }}
</head>
<body>
<div id="app" class="app-wrapper">
    <!-- Sidebar with separated UI chrome and content -->
    <div id="full-sidebar" class="full-sidebar">
        <div id="sidebar-tooling" class="sidebar-tooling">
                <button id="collapse-btn" class="collapse-btn" aria-label="Toggle sidebar">
                    <span class="material-symbols-rounded">keyboard_double_arrow_left</span>
                </button>
        </div>
        <!-- make sure this stays empty with no spaces - it uses the :empty selector to hide if there is nothing inside -->
        <div id="sidebar-container" class="sidebar-content" data-container="sidebar"></div>
    </div>
    <div class="layout-container">
        <div class="fixed-element"></div>
        <div id="main-container" class="main-layout" data-container="main">
            <p>Connecting to Jeamlit server...</p>
        </div>
    </div>
</div>

<!-- Connection Error Modal -->
<jt-connection-error-modal id="connection-modal" prevent-close>
    <span slot="title">Connection Error</span>
    <p>Is Jeamlit still running? If you accidentally stopped Jeamlit, just restart it in your terminal:</p>
    <jt-code content="jeamlit run YourApp.java"></jt-code>
</jt-connection-error-modal>

<!-- Compilation Error Modal -->
<jt-connection-error-modal id="compilation-modal">
    <span slot="title">Compilation error</span>
    <p>Fix the compilation errors below and save the file to continue:</p>
    <jt-code id="compilation-code" content=""></jt-code>
</jt-connection-error-modal>

<script>
    const app = document.getElementById('app');
    const mainContainer = document.getElementById('main-container');
    const fullSidebar = document.getElementById('full-sidebar');
    const sidebarContainer = document.getElementById('sidebar-container');
    const collapseBtn = document.getElementById('collapse-btn');
    const connectionModal = document.getElementById('connection-modal');
    const compilationModal = document.getElementById('compilation-modal');
    const compilationCode = document.getElementById('compilation-code');

    // Track if this is the first message to clear connecting text
    let isFirstMessage = true;

    // Connection management
    let ws = null;
    let connectionState = 'disconnected'; // 'connected', 'disconnected', 'reconnecting'

    // Sidebar collapse state management
    let sidebarCollapsed = localStorage.getItem('jeamlit-sidebar-collapsed') === 'true';
    
    // Sidebar resize state
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    let animationFrameId = null;
    const MIN_SIDEBAR_WIDTH = 150;
    const MAX_SIDEBAR_WIDTH = 500;
    const DEFAULT_SIDEBAR_WIDTH = 256;

    function initializeSidebar() {
        if (sidebarCollapsed) {
            fullSidebar.classList.add('collapsed');
        } else {
            // Restore saved width if not collapsed
            const savedWidth = localStorage.getItem('jeamlit-sidebar-width');
            if (savedWidth) {
                fullSidebar.style.width = savedWidth + 'px';
            }
        }
        
        collapseBtn.addEventListener('click', toggleSidebarCollapse);
        
        // Enable resize functionality
        enableSidebarResize();
    }
    
    function enableSidebarResize() {
        // Create resize handle
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'sidebar-resize-handle';
        fullSidebar.appendChild(resizeHandle);
        
        // Mouse events
        resizeHandle.addEventListener('mousedown', initResize);
        
        // Touch events for mobile
        resizeHandle.addEventListener('touchstart', initResize, { passive: false });
    }
    
    function initResize(e) {
        if (sidebarCollapsed) return;
        
        isResizing = true;
        startX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
        startWidth = parseInt(getComputedStyle(fullSidebar).width, 10);
        
        // Disable transition during drag to prevent lag
        fullSidebar.style.transition = 'none';
        
        document.body.classList.add('resizing');
        
        // Add listeners to document for drag/end
        document.addEventListener('mousemove', doResize);
        document.addEventListener('mouseup', stopResize);
        document.addEventListener('touchmove', doResize, { passive: false });
        document.addEventListener('touchend', stopResize);
        
        e.preventDefault();
    }
    
    function doResize(e) {
        if (!isResizing) return;
        
        // Cancel previous frame if pending
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        
        // Use requestAnimationFrame for smooth updates
        animationFrameId = requestAnimationFrame(() => {
            const currentX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
            const newWidth = Math.min(MAX_SIDEBAR_WIDTH, Math.max(MIN_SIDEBAR_WIDTH, startWidth + currentX - startX));
            
            fullSidebar.style.width = newWidth + 'px';
            animationFrameId = null;
        });
        
        e.preventDefault();
    }
    
    function stopResize(e) {
        if (!isResizing) return;
        
        isResizing = false;
        document.body.classList.remove('resizing');
        
        // Cancel any pending animation frame
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        
        // Re-enable transition after drag
        fullSidebar.style.transition = '';
        
        // Save width
        if (!sidebarCollapsed) {
            const currentWidth = fullSidebar.offsetWidth;
            localStorage.setItem('jeamlit-sidebar-width', currentWidth);
        }
        
        // Remove document listeners
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', stopResize);
        document.removeEventListener('touchmove', doResize);
        document.removeEventListener('touchend', stopResize);
    }

    function toggleSidebarCollapse() {
        sidebarCollapsed = !sidebarCollapsed;
        
        if (sidebarCollapsed) {
            // Save current width before collapsing
            const currentWidth = fullSidebar.offsetWidth;
            if (currentWidth > 24) {
                localStorage.setItem('jeamlit-sidebar-expanded-width', currentWidth);
            }
            fullSidebar.classList.add('collapsed');
            fullSidebar.style.width = '24px';
        } else {
            // Restore saved width when expanding
            fullSidebar.classList.remove('collapsed');
            const savedWidth = localStorage.getItem('jeamlit-sidebar-expanded-width') || 
                              localStorage.getItem('jeamlit-sidebar-width') || 
                              DEFAULT_SIDEBAR_WIDTH;
            fullSidebar.style.width = savedWidth + 'px';
        }
        
        // Store state in localStorage
        localStorage.setItem('jeamlit-sidebar-collapsed', sidebarCollapsed.toString());
    }

    window.jeamlit = {
        sendComponentUpdate: function(componentKey, value) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'component_update',
                    componentKey: componentKey,
                    value: value
                }));
            } else {
                console.log("Failed to send update to backend. Connection to backend is not available.");
            }
        },
        sendPathUpdate: function() {
            // Parse query parameters using URLSearchParams
            const params = new URLSearchParams(window.location.search);
            const queryObj = {};
            for (const key of params.keys()) {
                queryObj[key] = params.getAll(key);
            }

            // Send path_update message to backend to trigger app re-run
            window.jeamlit.sendMessage({
                type: 'path_update',
                path: window.location.pathname,
                queryParameters: queryObj,
            });
        },
        sendMessage: function(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                console.log("Failed to send message to backend. Connection to backend is not available.");
            }
        },
    };

    // Connection management functions
    function createWebSocketConnection() {
        try {
            ws = new WebSocket('ws://localhost:{{ port }}/ws');

            ws.onclose = () => {
                console.log('WebSocket closed');
                handleConnectionLoss();
            };

            ws.onmessage = handleWebSocketMessage;

            ws.onopen = () => {
                window.jeamlit.sendPathUpdate();
                connectionState = 'connected';
                console.log('WebSocket connected');
                connectionModal.show = false;
                compilationModal.show = false;
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

        } catch (error) {
            console.error('Failed to create WebSocket:', error);
            handleConnectionLoss();
        }
    }

    function handleConnectionLoss() {
        if (connectionState === 'connected') {
            // First time losing connection - show the connection lost modal
            // wait 1s to avoid modal flickerings when a page is reloaded
            setTimeout( () => {connectionModal.show = true;}, 1000)
        }
        connectionState = 'reconnecting';
        setTimeout(() => {
            console.log('Attempting to reconnect...');
            createWebSocketConnection();
        }, 5000);
        
        // Clear websocket references
        ws = null;
    }

    function handleWebSocketMessage(event) {
        const message = JSON.parse(event.data);
        if (message.type === 'delta') {
            applyDelta(message);
        } else if (message.type === 'compilation_error') {
            showCompilationError(message.error);
        } else {
            alert(`Unknown message type ${message.type}. Please reach out to support.`);
        }
    }

    // Layout management
    const layoutContainers = new Map([
        ['main', mainContainer],
        ['sidebar', sidebarContainer] // Backend content goes to the inner container
    ]);

    // DOM mutation batching
    let pendingMutations = [];
    let mutationTimeout = null;
    let firstMutationTime = null;
    // mutations received at less than 4ms (~1 frame at 240fps) of space are batched together to avoid flickering
    // every time a mutation is received the 4ms time is reset ...
    const MUTATION_BATCH_WINDOW = 4;
    // ... so we set a hard limit to flush the batch of 16ms ~ 1 frame at 60fps
    // FIXME this means animation will only run at max 60fps (assuming 0 latency network) so we may want to make this value configurable
    //   in any case streamlit does not ensure constant frame rate because of the delivery via ws
    const MAX_BATCH_WAIT_TIME = 16;

    function createElementFromHTML(htmlString) {
        if (!htmlString) {
            return null;
        }
        const template = document.createElement('template');
        template.innerHTML = htmlString.trim();
        return template.content.firstChild;
    }

    function handleComponentRegistrations(registrations) {
        if (!registrations || registrations.length === 0) return;

        // Ensure a hidden container is present
        let container = document.getElementById('jeamlit-registrations');
        if (!container) {
            container = document.createElement('div');
            container.id = 'jeamlit-registrations';
            container.style.display = 'none';
            document.body.appendChild(container);
        }

        registrations.forEach((registration) => {
            // Parse the registration HTML safely
            const template = document.createElement('template');
            template.innerHTML = registration;
            const fragment = template.content;

            // Execute all <script> tags inside the fragment
            fragment.querySelectorAll('script').forEach((script) => {
                const newScript = document.createElement('script');
                if (script.type) newScript.type = script.type;
                if (script.src) {
                    newScript.src = script.src;
                } else {
                    newScript.textContent = script.textContent;
                }
                document.head.appendChild(newScript);
            });

            // Inject the rest of the HTML (custom elements etc.)
            container.appendChild(fragment);
        });
    }

    function applyDelta(message) {
        const {
            index = null,                 // null means append
            html,
            container,                       // should always be set
            clearBefore = false           // Default to no clearing
        } = message;

        // Clear initial "Connecting..." message on first delta
        if (isFirstMessage) {
            mainContainer.innerHTML = '';
            isFirstMessage = false;
        }

        // Close compilation modal since we're receiving successful deltas
        compilationModal.show = false;

        // Handle component registrations immediately
        handleComponentRegistrations(message.registrations);

        // Create element immediately (outside batch)
        const newElement = createElementFromHTML(html);

        // Queue DOM mutations
        pendingMutations.push({
            type: 'delta',
            index,
            element: newElement,
            container: container,
            clearBefore
        });

        // Track first mutation time
        if (!firstMutationTime) {
            firstMutationTime = Date.now();
        }

        // Check if we've waited too long
        const elapsed = Date.now() - firstMutationTime;
        if (elapsed >= MAX_BATCH_WAIT_TIME) {
            // Force immediate processing to prevent starvation
            if (mutationTimeout) {
                clearTimeout(mutationTimeout);
                mutationTimeout = null;
            }
            processMutations();
            firstMutationTime = null;
        } else {
            // Normal batch processing
            if (mutationTimeout) {
                clearTimeout(mutationTimeout);
            }

            mutationTimeout = setTimeout(() => {
                processMutations();
                mutationTimeout = null;
                firstMutationTime = null;
            }, MUTATION_BATCH_WINDOW);
        }
    }

    function processMutations() {
        if (pendingMutations.length === 0) return;

        requestAnimationFrame(() => {
            // Group mutations by container
            const mutationsByContainer = new Map();

            pendingMutations.forEach(mutation => {
                // Get target container for this container
                if (!mutationsByContainer.has(mutation.container)) {
                    mutationsByContainer.set(mutation.container, []);
                }
                mutationsByContainer.get(mutation.container).push(mutation);
            });

            // Process mutations for each container separately
            mutationsByContainer.forEach((mutations, container) => {
                const containerEl = document.querySelector(`[data-container="${container}"]`);
                if (!containerEl) {
                    throw new Error(`Nested container not found for path: ${container}. Implementation error. Please reach out to support.`);
                }

                mutations.forEach(mutation => {
                    if (mutation.clearBefore && mutation.index !== null) {
                        while (containerEl.children.length > mutation.index) {
                            containerEl.removeChild(containerEl.lastChild);
                        }
                    }
                    // in the clearing case, it can happen that the element is null to trigger a full cleanup - so checking here but not below
                    if (mutation.element) {
                        if (mutation.index !== null && mutation.index < containerEl.children.length) {
                            containerEl.children[mutation.index].replaceWith(mutation.element);
                        } else {
                            containerEl.appendChild(mutation.element);
                        }
                    }
                });
            });

            pendingMutations = [];
        });
    }

    function showCompilationError(error) {
        // Set the error message in the jt-code component
        compilationCode.content = error;
        // Show the compilation modal
        compilationModal.show = true;
    }

    // Initialize sidebar and connection
    initializeSidebar();
    createWebSocketConnection();
</script>
</body>
</html>